import{_ as ve}from"./iframe-DUbgzP5M.js";const he="tommyzki-ui",A={hydratedSelectorName:"hydrated",lazyLoad:!0,updatable:!0,watchCallback:!1};var ge=Object.defineProperty,ye=(e,t)=>{for(var s in t)ge(e,s,{get:t[s],enumerable:!0})},m=e=>{if(e.__stencil__getHostRef)return e.__stencil__getHostRef()},Se=(e,t)=>{const s={$flags$:0,$hostElement$:e,$cmpMeta$:t,$instanceValues$:new Map};s.$onReadyPromise$=new Promise(r=>s.$onReadyResolve$=r),e["s-p"]=[],e["s-rc"]=[];const n=s;return e.__stencil__getHostRef=()=>n,n},me=(e,t)=>t in e,x=(e,t)=>(0,console.error)(e,t),J=new Map,Ee=(e,t,s)=>{const n=e.$tagName$.replace(/-/g,"_"),r=e.$lazyBundleId$;if(!r)return;const l=J.get(r);if(l)return l[n];/*!__STENCIL_STATIC_IMPORT_SWITCH__*/return ve(()=>import(`./${r}.entry.js`),[],import.meta.url).then(i=>(J.set(r,i),i[n]),i=>{x(i,t.$hostElement$)})},I=new Map,ke="sty-id",we="{visibility:hidden}.hydrated{visibility:inherit}",te="slot-fb{display:contents}slot-fb[hidden]{display:none}",y=typeof window<"u"?window:{},g={$flags$:0,$resourcesUrl$:"",jmp:e=>e(),raf:e=>requestAnimationFrame(e),ael:(e,t,s,n)=>e.addEventListener(t,s,n),rel:(e,t,s,n)=>e.removeEventListener(t,s,n),ce:(e,t)=>new CustomEvent(e,t)},be=e=>Promise.resolve(e),ne=(()=>{try{return new CSSStyleSheet,typeof new CSSStyleSheet().replaceSync=="function"}catch{}return!1})(),j=!1,K=[],se=[],_e=(e,t)=>s=>{e.push(s),j||(j=!0,g.$flags$&4?C(D):g.raf(D))},Q=e=>{for(let t=0;t<e.length;t++)try{e[t](performance.now())}catch(s){x(s)}e.length=0},D=()=>{Q(K),Q(se),(j=K.length>0)&&g.raf(D)},C=e=>be().then(e),xe=_e(se),M=e=>(e=typeof e,e==="object"||e==="function");function re(e){var t,s,n;return(n=(s=(t=e.head)==null?void 0:t.querySelector('meta[name="csp-nonce"]'))==null?void 0:s.getAttribute("content"))!=null?n:void 0}var Le=e=>e.replace(/[.*+?^${}()|[\]\\]/g,"\\$&"),Te={};ye(Te,{err:()=>oe,map:()=>Pe,ok:()=>U,unwrap:()=>ze,unwrapErr:()=>Ae});var U=e=>({isOk:!0,isErr:!1,value:e}),oe=e=>({isOk:!1,isErr:!0,value:e});function Pe(e,t){if(e.isOk){const s=t(e.value);return s instanceof Promise?s.then(n=>U(n)):U(s)}if(e.isErr){const s=e.value;return oe(s)}throw"should never get here"}var ze=e=>{if(e.isOk)return e.value;throw e.value},Ae=e=>{if(e.isErr)return e.value;throw e.value},E=(e,t="")=>()=>{},Ie=(e,t)=>()=>{},He=(e,t,...s)=>{let n=null,r=null,l=!1,i=!1;const o=[],$=c=>{for(let f=0;f<c.length;f++)n=c[f],Array.isArray(n)?$(n):n!=null&&typeof n!="boolean"&&((l=!M(n))&&(n=String(n)),l&&i?o[o.length-1].$text$+=n:o.push(l?R(null,n):n),i=l)};$(s);const a=R(e,null);return a.$attrs$=t,o.length>0&&(a.$children$=o),a.$key$=r,a},R=(e,t)=>{const s={$flags$:0,$tag$:e,$text$:t,$elm$:null,$children$:null};return s.$attrs$=null,s.$key$=null,s},Oe={},je=e=>e&&e.$tag$===Oe,W=e=>{const t=Le(e);return new RegExp(`(^|[^@]|@(?!supports\\s+selector\\s*\\([^{]*?${t}))(${t}\\b)`,"g")};W("::slotted");W(":host");W(":host-context");var q=(e,t)=>e!=null&&!M(e)?t&4?e==="false"?!1:e===""||!!e:t&1?String(e):e:e,De=(e,t,s)=>{const n=g.ce(t,s);return e.dispatchEvent(n),n},_=new WeakMap,Ue=(e,t,s)=>{let n=I.get(e);ne&&s?(n=n||new CSSStyleSheet,typeof n=="string"?n=t:n.replaceSync(t)):n=t,I.set(e,n)},Re=(e,t,s)=>{var n;const r=le(t),l=I.get(r);if(!y.document)return r;if(e=e.nodeType===11?e:y.document,l)if(typeof l=="string"){e=e.head||e;let i=_.get(e),o;if(i||_.set(e,i=new Set),!i.has(r)){{o=document.querySelector(`[${ke}="${r}"]`)||y.document.createElement("style"),o.innerHTML=l;const $=(n=g.$nonce$)!=null?n:re(y.document);if($!=null&&o.setAttribute("nonce",$),!(t.$flags$&1))if(e.nodeName==="HEAD"){const a=e.querySelectorAll("link[rel=preconnect]"),c=a.length>0?a[a.length-1].nextSibling:e.querySelector("style");e.insertBefore(o,c?.parentNode===e?c:null)}else if("host"in e)if(ne){const a=new CSSStyleSheet;a.replaceSync(l),e.adoptedStyleSheets=[a,...e.adoptedStyleSheets]}else{const a=e.querySelector("style");a?a.innerHTML=l+a.innerHTML:e.prepend(o)}else e.append(o);t.$flags$&1&&e.insertBefore(o,null)}t.$flags$&4&&(o.innerHTML+=te),i&&i.add(r)}}else e.adoptedStyleSheets.includes(l)||(e.adoptedStyleSheets=[...e.adoptedStyleSheets,l]);return r},qe=e=>{const t=e.$cmpMeta$,s=e.$hostElement$,n=t.$flags$,r=E("attachStyles",t.$tagName$),l=Re(s.shadowRoot?s.shadowRoot:s.getRootNode(),t);n&10&&(s["s-sc"]=l,s.classList.add(l+"-h")),r()},le=(e,t)=>"sc-"+e.$tagName$,X=(e,t,s,n,r,l,i)=>{if(s===n)return;let o=me(e,t);if(t.toLowerCase(),t==="class"){const $=e.classList,a=F(s);let c=F(n);$.remove(...a.filter(f=>f&&!c.includes(f))),$.add(...c.filter(f=>f&&!a.includes(f)))}else if(t!=="key"){const $=M(n);if(o||$&&n!==null)try{if(e.tagName.includes("-"))e[t]!==n&&(e[t]=n);else{const a=n??"";t==="list"?o=!1:(s==null||e[t]!=a)&&(typeof e.__lookupSetter__(t)=="function"?e[t]=a:e.setAttribute(t,a))}}catch{}n==null||n===!1?(n!==!1||e.getAttribute(t)==="")&&e.removeAttribute(t):(!o||l&4||r)&&!$&&e.nodeType===1&&(n=n===!0?"":n,e.setAttribute(t,n))}},Be=/\s/,F=e=>(typeof e=="object"&&e&&"baseVal"in e&&(e=e.baseVal),!e||typeof e!="string"?[]:e.split(Be)),ie=(e,t,s,n)=>{const r=t.$elm$.nodeType===11&&t.$elm$.host?t.$elm$.host:t.$elm$,l=e&&e.$attrs$||{},i=t.$attrs$||{};for(const o of V(Object.keys(l)))o in i||X(r,o,l[o],void 0,s,t.$flags$);for(const o of V(Object.keys(i)))X(r,o,l[o],i[o],s,t.$flags$)};function V(e){return e.includes("ref")?[...e.filter(t=>t!=="ref"),"ref"]:e}var Y,ae=!1,H=(e,t,s)=>{const n=t.$children$[s];let r=0,l,i;if(n.$text$!==null)l=n.$elm$=y.document.createTextNode(n.$text$);else{if(!y.document)throw new Error("You are trying to render a Stencil component in an environment that doesn't support the DOM. Make sure to populate the [`window`](https://developer.mozilla.org/en-US/docs/Web/API/Window/window) object before rendering a component.");if(l=n.$elm$=y.document.createElement(n.$tag$),ie(null,n,ae),n.$children$)for(r=0;r<n.$children$.length;++r)i=H(e,n,r),i&&l.appendChild(i)}return l["s-hn"]=Y,l},$e=(e,t,s,n,r,l)=>{let i=e,o;for(i.shadowRoot&&i.tagName===Y&&(i=i.shadowRoot);r<=l;++r)n[r]&&(o=H(null,s,r),o&&(n[r].$elm$=o,z(i,o,t)))},ce=(e,t,s)=>{for(let n=t;n<=s;++n){const r=e[n];if(r){const l=r.$elm$;l&&l.remove()}}},Ce=(e,t,s,n,r=!1)=>{let l=0,i=0,o=0,$=0,a=t.length-1,c=t[0],f=t[a],d=n.length-1,u=n[0],p=n[d],h,v;for(;l<=a&&i<=d;)if(c==null)c=t[++l];else if(f==null)f=t[--a];else if(u==null)u=n[++i];else if(p==null)p=n[--d];else if(P(c,u,r))b(c,u,r),c=t[++l],u=n[++i];else if(P(f,p,r))b(f,p,r),f=t[--a],p=n[--d];else if(P(c,p,r))b(c,p,r),z(e,c.$elm$,f.$elm$.nextSibling),c=t[++l],p=n[--d];else if(P(f,u,r))b(f,u,r),z(e,f.$elm$,c.$elm$),f=t[--a],u=n[++i];else{for(o=-1,$=l;$<=a;++$)if(t[$]&&t[$].$key$!==null&&t[$].$key$===u.$key$){o=$;break}o>=0?(v=t[o],v.$tag$!==u.$tag$?h=H(t&&t[i],s,o):(b(v,u,r),t[o]=void 0,h=v.$elm$),u=n[++i]):(h=H(t&&t[i],s,i),u=n[++i]),h&&z(c.$elm$.parentNode,h,c.$elm$)}l>a?$e(e,n[d+1]==null?null:n[d+1].$elm$,s,n,i,d):i>d&&ce(t,l,a)},P=(e,t,s=!1)=>e.$tag$===t.$tag$?s?(s&&!e.$key$&&t.$key$&&(e.$key$=t.$key$),!0):e.$key$===t.$key$:!1,b=(e,t,s=!1)=>{const n=t.$elm$=e.$elm$,r=e.$children$,l=t.$children$,i=t.$text$;i===null?(ie(e,t,ae),r!==null&&l!==null?Ce(n,r,t,l,s):l!==null?(e.$text$!==null&&(n.textContent=""),$e(n,null,t,l,0,l.length-1)):!s&&A.updatable&&r!==null&&ce(r,0,r.length-1)):e.$text$!==i&&(n.data=i)},z=(e,t,s)=>e?.insertBefore(t,s),Me=(e,t,s=!1)=>{const n=e.$hostElement$,r=e.$vnode$||R(null,null),i=je(t)?t:He(null,null,t);if(Y=n.tagName,s&&i.$attrs$)for(const o of Object.keys(i.$attrs$))n.hasAttribute(o)&&!["key","ref","style","class"].includes(o)&&(i.$attrs$[o]=n[o]);i.$tag$=null,i.$flags$|=4,e.$vnode$=i,i.$elm$=r.$elm$=n.shadowRoot||n,b(r,i,s)},de=(e,t)=>{if(t&&!e.$onRenderResolve$&&t["s-p"]){const s=t["s-p"].push(new Promise(n=>e.$onRenderResolve$=()=>{t["s-p"].splice(s-1,1),n()}))}},G=(e,t)=>{if(e.$flags$|=16,e.$flags$&4){e.$flags$|=512;return}return de(e,e.$ancestorComponent$),xe(()=>We(e,t))},We=(e,t)=>{const s=e.$hostElement$,n=E("scheduleUpdate",e.$cmpMeta$.$tagName$),r=e.$lazyInstance$;if(!r)throw new Error(`Can't render component <${s.tagName.toLowerCase()} /> with invalid Stencil runtime! Make sure this imported component is compiled with a \`externalRuntime: true\` flag. For more information, please refer to https://stenciljs.com/docs/custom-elements#externalruntime`);let l;return t?l=k(r,"componentWillLoad",void 0,s):l=k(r,"componentWillUpdate",void 0,s),l=N(l,()=>k(r,"componentWillRender",void 0,s)),n(),N(l,()=>Ge(e,r,t))},N=(e,t)=>Ye(e)?e.then(t).catch(s=>{console.error(s),t()}):t(),Ye=e=>e instanceof Promise||e&&e.then&&typeof e.then=="function",Ge=async(e,t,s)=>{var n;const r=e.$hostElement$,l=E("update",e.$cmpMeta$.$tagName$),i=r["s-rc"];s&&qe(e);const o=E("render",e.$cmpMeta$.$tagName$);Ze(e,t,r,s),i&&(i.map($=>$()),r["s-rc"]=void 0),o(),l();{const $=(n=r["s-p"])!=null?n:[],a=()=>Je(e);$.length===0?a():(Promise.all($).then(a),e.$flags$|=4,$.length=0)}},Ze=(e,t,s,n)=>{try{t=t.render(),e.$flags$&=-17,e.$flags$|=2,Me(e,t,n)}catch(r){x(r,e.$hostElement$)}return null},Je=e=>{const t=e.$cmpMeta$.$tagName$,s=e.$hostElement$,n=E("postUpdate",t),r=e.$lazyInstance$,l=e.$ancestorComponent$;k(r,"componentDidRender",void 0,s),e.$flags$&64?(k(r,"componentDidUpdate",void 0,s),n()):(e.$flags$|=64,Ke(s),k(r,"componentDidLoad",void 0,s),n(),e.$onReadyResolve$(s),l||fe()),e.$onRenderResolve$&&(e.$onRenderResolve$(),e.$onRenderResolve$=void 0),e.$flags$&512&&C(()=>G(e,!1)),e.$flags$&=-517},fe=e=>{C(()=>De(y,"appload",{detail:{namespace:he}}))},k=(e,t,s,n)=>{if(e&&e[t])try{return e[t](s)}catch(r){x(r,n)}},Ke=e=>{var t;return e.classList.add((t=A.hydratedSelectorName)!=null?t:"hydrated")},Qe=(e,t)=>m(e).$instanceValues$.get(t),O=(e,t,s,n)=>{const r=m(e);if(!r)throw new Error(`Couldn't find host element for "${n.$tagName$}" as it is unknown to this Stencil runtime. This usually happens when integrating a 3rd party Stencil component with another Stencil component or application. Please reach out to the maintainers of the 3rd party Stencil component or report this on the Stencil Discord server (https://chat.stenciljs.com) or comment on this similar [GitHub issue](https://github.com/stenciljs/core/issues/5457).`);const l=r.$instanceValues$.get(t),i=r.$flags$,o=r.$lazyInstance$;s=q(s,n.$members$[t][0]);const $=Number.isNaN(l)&&Number.isNaN(s),a=s!==l&&!$;if((!(i&8)||l===void 0)&&a&&(r.$instanceValues$.set(t,s),o&&(i&18)===2)){if(o.componentShouldUpdate&&o.componentShouldUpdate(s,l,t)===!1)return;G(r,!1)}},ue=(e,t,s)=>{var n,r;const l=e.prototype;if(t.$members$||A.watchCallback){const i=Object.entries((n=t.$members$)!=null?n:{});if(i.map(([o,[$]])=>{if($&31||s&2&&$&32){const{get:a,set:c}=Object.getOwnPropertyDescriptor(l,o)||{};a&&(t.$members$[o][0]|=2048),c&&(t.$members$[o][0]|=4096),(s&1||!a)&&Object.defineProperty(l,o,{get(){{if((t.$members$[o][0]&2048)===0)return Qe(this,o);const f=m(this),d=f?f.$lazyInstance$:l;return d?d[o]:void 0}},configurable:!0,enumerable:!0}),Object.defineProperty(l,o,{set(f){const d=m(this);if(c){const u=$&32?this[o]:d.$hostElement$[o];typeof u>"u"&&d.$instanceValues$.get(o)?f=d.$instanceValues$.get(o):!d.$instanceValues$.get(o)&&u&&d.$instanceValues$.set(o,u),c.apply(this,[q(f,$)]),f=$&32?this[o]:d.$hostElement$[o],O(this,o,f,t);return}{if((s&1)===0||(t.$members$[o][0]&4096)===0){O(this,o,f,t),s&1&&!d.$lazyInstance$&&d.$onReadyPromise$.then(()=>{t.$members$[o][0]&4096&&d.$lazyInstance$[o]!==d.$instanceValues$.get(o)&&(d.$lazyInstance$[o]=f)});return}const u=()=>{const p=d.$lazyInstance$[o];!d.$instanceValues$.get(o)&&p&&d.$instanceValues$.set(o,p),d.$lazyInstance$[o]=q(f,$),O(this,o,d.$lazyInstance$[o],t)};d.$lazyInstance$?u():d.$onReadyPromise$.then(()=>u())}}})}}),s&1){const o=new Map;l.attributeChangedCallback=function($,a,c){g.jmp(()=>{var f;const d=o.get($);if(this.hasOwnProperty(d)&&A.lazyLoad)c=this[d],delete this[d];else{if(l.hasOwnProperty(d)&&typeof this[d]=="number"&&this[d]==c)return;if(d==null){const p=m(this),h=p?.$flags$;if(h&&!(h&8)&&h&128&&c!==a){const v=p.$lazyInstance$,w=(f=t.$watchers$)==null?void 0:f[$];w?.forEach(L=>{v[L]!=null&&v[L].call(v,c,a,$)})}return}}const u=Object.getOwnPropertyDescriptor(l,d);c=c===null&&typeof this[d]=="boolean"?!1:c,c!==this[d]&&(!u.get||u.set)&&(this[d]=c)})},e.observedAttributes=Array.from(new Set([...Object.keys((r=t.$watchers$)!=null?r:{}),...i.filter(([$,a])=>a[0]&15).map(([$,a])=>{const c=a[1]||$;return o.set(c,$),c})]))}}return e},Xe=async(e,t,s,n)=>{let r;if((t.$flags$&32)===0){if(t.$flags$|=32,s.$lazyBundleId$){const $=Ee(s,t);if($&&"then"in $){const c=Ie();r=await $,c()}else r=$;if(!r)throw new Error(`Constructor for "${s.$tagName$}#${t.$modeName$}" was not found`);r.isProxied||(ue(r,s,2),r.isProxied=!0);const a=E("createInstance",s.$tagName$);t.$flags$|=8;try{new r(t)}catch(c){x(c,e)}t.$flags$&=-9,a(),B(t.$lazyInstance$,e)}else{r=e.constructor;const $=e.localName;customElements.whenDefined($).then(()=>t.$flags$|=128)}if(r&&r.style){let $;typeof r.style=="string"&&($=r.style);const a=le(s);if(!I.has(a)){const c=E("registerStyles",s.$tagName$);Ue(a,$,!!(s.$flags$&1)),c()}}}const l=t.$ancestorComponent$,i=()=>G(t,!0);l&&l["s-rc"]?l["s-rc"].push(i):i()},B=(e,t)=>{k(e,"connectedCallback",void 0,t)},Fe=e=>{if((g.$flags$&1)===0){const t=m(e),s=t.$cmpMeta$,n=E("connectedCallback",s.$tagName$);if(t.$flags$&1)t?.$lazyInstance$?B(t.$lazyInstance$,e):t?.$onReadyPromise$&&t.$onReadyPromise$.then(()=>B(t.$lazyInstance$,e));else{t.$flags$|=1;{let r=e;for(;r=r.parentNode||r.host;)if(r["s-p"]){de(t,t.$ancestorComponent$=r);break}}s.$members$&&Object.entries(s.$members$).map(([r,[l]])=>{if(l&31&&e.hasOwnProperty(r)){const i=e[r];delete e[r],e[r]=i}}),Xe(e,t,s)}n()}},ee=(e,t)=>{k(e,"disconnectedCallback",void 0,t||e)},Ve=async e=>{if((g.$flags$&1)===0){const t=m(e);t?.$lazyInstance$?ee(t.$lazyInstance$,e):t?.$onReadyPromise$&&t.$onReadyPromise$.then(()=>ee(t.$lazyInstance$,e))}_.has(e)&&_.delete(e),e.shadowRoot&&_.has(e.shadowRoot)&&_.delete(e.shadowRoot)},Ne=(e,t={})=>{var s;if(!y.document){console.warn("Stencil: No document found. Skipping bootstrapping lazy components.");return}const n=E(),r=[],l=t.exclude||[],i=y.customElements,o=y.document.head,$=o.querySelector("meta[charset]"),a=y.document.createElement("style"),c=[];let f,d=!0;Object.assign(g,t),g.$resourcesUrl$=new URL(t.resourcesUrl||"./",y.document.baseURI).href;let u=!1;if(e.map(p=>{p[1].map(h=>{const v={$flags$:h[0],$tagName$:h[1],$members$:h[2],$listeners$:h[3]};v.$flags$&4&&(u=!0),v.$members$=h[2];const w=v.$tagName$,L=class extends HTMLElement{constructor(S){if(super(S),this.hasRegisteredEventListeners=!1,S=this,Se(S,v),v.$flags$&1){if(!S.shadowRoot)S.attachShadow({mode:"open"});else if(S.shadowRoot.mode!=="open")throw new Error(`Unable to re-use existing shadow root for ${v.$tagName$}! Mode is set to ${S.shadowRoot.mode} but Stencil only supports open shadow roots.`)}}connectedCallback(){m(this),this.hasRegisteredEventListeners||(this.hasRegisteredEventListeners=!0),f&&(clearTimeout(f),f=null),d?c.push(this):g.jmp(()=>Fe(this))}disconnectedCallback(){g.jmp(()=>Ve(this)),g.raf(()=>{var S;const T=m(this),Z=c.findIndex(pe=>pe===this);Z>-1&&c.splice(Z,1),((S=T?.$vnode$)==null?void 0:S.$elm$)instanceof Node&&!T.$vnode$.$elm$.isConnected&&delete T.$vnode$.$elm$})}componentOnReady(){return m(this).$onReadyPromise$}};v.$lazyBundleId$=p[0],!l.includes(w)&&!i.get(w)&&(r.push(w),i.define(w,ue(L,v,1)))})}),r.length>0&&(u&&(a.textContent+=te),a.textContent+=r.sort()+we,a.innerHTML.length)){a.setAttribute("data-styles","");const p=(s=g.$nonce$)!=null?s:re(y.document);p!=null&&a.setAttribute("nonce",p),o.insertBefore(a,$?$.nextSibling:o.firstChild)}d=!1,c.length?c.map(p=>p.connectedCallback()):g.jmp(()=>f=setTimeout(fe,30)),n()};const et=()=>{},tt=async(e,t)=>{if(!(typeof window>"u"))return await et(),Ne([["tommyzki-button",[[1,"tommyzki-button",{variant:[1],size:[1],disabled:[4],loading:[4],fullwidth:[4],rounded:[4]}]]]],t)};(function(){if(typeof window<"u"&&window.Reflect!==void 0&&window.customElements!==void 0){var e=HTMLElement;window.HTMLElement=function(){return Reflect.construct(e,[],this.constructor)},HTMLElement.prototype=e.prototype,HTMLElement.prototype.constructor=HTMLElement,Object.setPrototypeOf(HTMLElement,e)}})();tt();const st={parameters:{actions:{argTypesRegex:"^on[A-Z].*"},controls:{matchers:{color:/(background|color)$/i,date:/Date$/i}}}};export{st as default};
